# 网络是怎样连接的 Notes


## 第一章
### 1.1 生成HTTP请求消息

#### URL解析

URL: Uniform Resourse Locator, 统一资源定位符

HTTP：Hypertext Transfer Protocol，超文本传送协议

根据访问目标的不同，URL 的写法也会不同，浏览器生成请求的内容也会不一样。

URL的各种格式

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311195605471.png" alt="image-20220311195605471" style="zoom:80%;" />

浏览器的第一步工作就是对URL进行解析，Web浏览器解析URL的过程如下图

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311195834062.png" alt="image-20220311195834062" style="zoom:80%;" />

Web服务器文件树示例

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311195959060.png" alt="image-20220311195959060" style="zoom:80%;" />

省略文件名的情况：

1. http://www.lab.glasscom.com/dir/
   我们可以这样理解， 以“/” 结尾代表 /dir/ 后面本来应该有的文件名被省略了。 根据 URL 的规则，文件名可以像前面这样省略，此时服务器会默认访问 我们会在服务器上事先设置好的文件名省略时要访问的默认文件名。 这个设置根据服务器不同而不同， 大多数情况下是 index.html 或者 default.htm 之类的文件名。 因此， 像前面这样省略文件名时， 服务器就会访问 /dir/index.html或者 /dir/default.htm。
   还有一些 URL 是像下面这样只有 Web 服务器的域名的， 这也是一种省略了文件名的形式。
2. http://www.lab.glasscom.com/
   这个 URL 也是以“/” 结尾的， 也就是说它表示访问一个名叫“/” 的目录 。 而且， 由于省略了文件名， 所以结果就是访问 /index.html 或者/default.htm 这样的文件了。
3. http://www.lab.glasscom.com
   这次连结尾的“/” 都省略了。 像这样连目录名都省略时， 真不知道到底在请求哪个文件了， 实在有些过分。 不过， 这种写法也是允许的。 当没有路径名时， 就代表访问根目录下事先设置的默认文件 ， 也就是 /index.html 或者 /default.htm 这些文件， 这样就不会发生混乱了。
4. http://www.lab.glasscom.com/whatisthis
   前面这个例子中， 由于末尾没有“/”， 所以 whatisthis 应该理 解为文件名才对。 但实际上， 很多人并没有正确理解省略文件名的规则， 经常会把目录末尾的“/” 也给省略了。 因此， 或许我们不应该总是将 whatisthis 作为文件名来处理。 一般来说， 这种情况会按照下面的惯例进行处理： 如果Web 服务器上存在名为 whatisthis 的文件， 则将 whatisthis 作为文件名来处理； 如果存在名为 whatisthis 的目录， 则将 whatisthis 作为目录名来处理。 

#### HTTP协议的基本思路

**HTTP协议的基本思路如图1.4所示。浏览器解析URL后，自动生成请求消息。请求消息可以看成请求方法+请求对象（URI, Uniform Resourse Identifier)+请求附加信息（+数据）。浏览器将请求消息委托给协议栈（因为浏览器本身不能发送请求消息），让协议栈发送给Web服务器，服务器解析请求消息获得请求数据返回请求消息，请求消息可以看成状态码+相应短语+附加信息（+数据）。协议栈接受响应消息传递给浏览器，浏览器会读取所需数据并显示在屏幕上。**

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311201100781.png" alt="image-20220311201100781" style="zoom:80%;" />

HTTP请求消息与相应消息的格式如图1.5所示。

无论是请求消息还是响应消息，基本格式都相同：请求行+消息头+空行+消息体。区别只在于请求行内容不同。请求消息的格式为：`<method><space><URI><space><HTTP Version>`，响应消息的格式为`<HTTP Version><space><状态码><space><相应短语>`。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311205355746.png" alt="image-20220311205355746" style="zoom:80%;" />

方法如下

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311205923830.png" alt="image-20220311205923830" style="zoom:80%;" />

HTTP消息头中的主要头字段如下

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311212043218.png" alt="image-20220311212043218" style="zoom: 50%;" />

HTTP相应消息状态码：

状态码和响应短语表示的内容一致， 但它们的用途不同。 状态码是一个数字， 它主要用来向程序告知执行的结果（表1.3）； 相对地， 响应短语则是一段文字， 用来向人们告知执行的结果。  

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311212942176.png" alt="image-20220311212942176" style="zoom:80%;" />

HTTP请求示例

由于每条请求消息中只能写 1 个 URI， 所以每次只能获取 1 个文件，如果需要获取多个文件， 必须对每个文件单独发送 1 条请求。  比如 1 个网页中包含 3 张图片， 那么获取网页加上获取图片， 一共需要向 Web 服务器发送 4 条请求。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311213204698.png" alt="image-20220311213204698" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311213219308.png" alt="image-20220311213219308" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311213229449.png" alt="image-20220311213229449" style="zoom:80%;" />

### 1.2 向 DNS 服务器查询 Web 服务器的 IP 地址  

浏览器本身不具有发送功能，它根据URL的协议的种类生成对应的请求消息后，要把请求消息委托给操作系统来发送。但是给操作系统发送的前提是知道目的地（比如：Web服务器）的ip地址。通过DNS（Domain Name System）解析器能将服务器域名解析为ip地址，这个操作被称之为**域名解析**。解析器本质上是一个程序。域名解析的代码很简单，就是调用一下Socket库中的`gethostbyname()`函数，输入参数为服务器域名，输出为域名对应的ip地址。（实际上， 实现解析器的功能需要多个程序相互配合，可能还会从gethostbyname 程序中调用其他的程序）域名解析的内部原理也容易理解。

#### TCP/IP 网络简述

TCP/IP 的结构如图 1.8 所示， 就是由一些小的子网， 通过路由器 A 连接起来组成一个大的网络。 这里的子网可以理解为用集线器 B 连接起来的几台计算机 C， 我们将它看作一个单位， 称为子网。  

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311224007044.png" alt="image-20220311224007044" style="zoom:80%;" />

#### IP地址

IP地址由网络号和主机号组成。网络号是分配给整个子网的，主机号是分配给子网中的网络设备的。

实际的 IP 地址是一串32 比特的数字， 按照 8 比特（ 1 字节） 为一组分成 4 组， 分别用十进制表示然后再用圆点隔开。   

域名与IP并用的理由：相较IP地址，域名更有意义，容易被人类记忆。域名虽然也可以代替IP地址确定通信对象。但是域名字节长度比IP的4字节要长，增加了路由器的负担，降低了通信的效率。于是人类用域名记忆通信对象，路由器用IP地址确定通信对象。为了建立起两者的转换关系，引入了DNS解析器。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311213717773.png" alt="image-20220311213717773" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311213724311.png" alt="image-20220311213724311" style="zoom:80%;" />

### 1.3 DNS服务器

#### 总述

DNS： Domain Name System，域名服务系统。将服务器名称和 IP 地址进行关联是 DNS 最常见的用法，但 DNS 的功能并不仅限于此，它还可以将邮件地址和邮件服务器进行关联，以及为各种信息关联相应的名称。  

解析器实际上是一段程序， 它包含在操作系统的 Socket 库中。调用解析器后， 解析器会向 DNS 服务器发送查询消息， 然后 DNS 服务器会返回响应消息。 响应消息中包含查询到的 IP 地址， 解析器会取出 IP地址， 并将其写入浏览器指定的内存地址中。   

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311224817773.png" alt="image-20220311224817773" style="zoom:80%;" />

#### 内部原理

几个注意的点：

- 解析器本质上是一段程序，所以可以把Socket理解成解析器。调用解析器就是调用`gethostbyname()`函数。

- `gethostbyname()`函数负责生成了DNS服务器的查询消息和接受DNS服务器返回的响应消息。
- 如果要向DNS服务器发送询问请求，也要事先知道DNS服务器的IP地址。只不过这个 IP 地址是作为 TCP/IP 的一个设置项目事先设
  置好的，不需要再去查询了。Window7系统DNS服务器IP地址如图1.13所示。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220312110513634.png" alt="image-20220312110513634" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311230118617.png" alt="image-20220311230118617" style="zoom:80%;" />

DNS解析器生成的查询消息包含包含以下 3 种信息。

- 域名
  服务器、 邮件服务器（ 邮件地址中 @ 后面的部分） 的名称
- Class
  在最早设计 DNS 方案时， DNS 在互联网以外的其他网络中的应用  也被考虑到了， 而 Class 就是用来识别网络的信息。 不过， 如今除了互联网并没有其他的网络了， 因此 Class 的值永远是代表互联网的 IN。

- 记录类型
  表示域名对应何种类型的记录。 例如， 当类型为 A 时， 表示域名对应的是 IP 地址； 当类型为 MX 时， 表示域名对应的是邮件服务器。 对于不同的记录类型， 服务器向客户端返回的信息也会不同。

DNS 服务器上事先保存有前面这 3 种信息对应的记录数据， 如图 1.14所示。DNS 服务器就是根据这些记录查找符合查询请求的内容并对客户端作出响应的。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220311230619073.png" alt="image-20220311230619073" style="zoom:80%;" />

注：

- A 是 Address 的缩写。  
- 不仅是 Web 服务器，像邮件服务器、数据库服务器等，无论任何服务器，只要注册了 A 类型的记录，都可以作为服务器的域名来使用。准确来说，A 类型的记录表示与 IP 地址所对应的域名，因此与其说是某个服务器的域名，不如说是被分配了某个 IP 地址的某台具体设备的域名。  
- MX： Mail eXchange，邮件交换。  

#### 域名的层级结构

 **互联网中存在着不计其数的服务器，将这些服务器的信息全部保存在一台DNS服务器中是不可能的，因此一定会出现在DNS服务器中找不到要查询的信息的情况。信息分布保存在多台DNS服务器中，这些DNS服务器相互接力配合，从而查找出要查询的信息。**

首先，DNS服务器中的所有信息都是按照域名以分层次的结构来保存的。DNS中的域名都是用句点来分隔的，比如www.lab.glasscom.com，这里的句点代表了不同层次之间的界限，就相当于公司里面的组织结构不用部、科之类的名称来划分，只是用句点来分隔而已。在域名中，越靠右的位置表示其层级越高，比如www.lab.glasscom.com这个域名如果按照公司里的组织结构来说，大概就是“com事业集团glasscom部lab科的www”这样。其中，相当于一个层级的部分称为域。因此，com域的下一层是glasscom域，再下一层是lab域，再下面才是www这个名字。这种具有层次结构的域名信息会注册到DNS服务器中，而每个域都是作为一个整体来处理的。换句话说就是，一个域的信息是作为一个整体存放在DNS服务器中的，不能将一个域拆开来存放在多台DNS服务器中。不过，DNS服务器和域之间的关系也并不总是一对一的，一台DNS服务器中也可以存放多个域的信息。

先假设一台DNS服务器中只存放一个域的信息，来阐述**下级域**的关系。比如，假设公司的域为example.co.jp，我们可以在这个域的下面创建两个子域，即sub1.example.co.jp和sub2.example.co.jp，然后就可以将这两个下级域分配给不同的事业集团来使用。

**互联网中有数万台 DNS 服务器，当我们要找我们要访问的Web服务器属于哪台DNS服务器管的时候，肯定不能一台一台挨个去找。  IP地址是以层级划分的，域的信息也是按层级存储在DNS服务器中的。**将负责管理下级域的 DNS 服务器的 IP 地址注册到它们的上级 DNS 服务器中，然后上级 DNS 服务器的 IP 地址再注册到更上一级的 DNS 服务器中，以此类推。也就是说，负责管理lab.glasscom.com 这个域的 DNS 服务器的 IP 地址需要注册到 glasscom.com 域的 DNS服务器中， 而 glasscom.com 域的 DNS 服务器的 IP 地址又需要注册到 com域的 DNS 服务器中。 这样，我们就可以通过上级 DNS 服务器查询出下级 DNS 服务器的 IP 地址，也就可以向下级 DNS 服务器发送查询请求了。最顶层的域为根域。根域不像 com、 jp 那样有自己的名字， 因此在一般书写域名时经常被省略，如果要明确表示根域， 应该像 www.lab.glasscom.com. 这样在域名的最后再加上一个句点， 而这个最后的句点就代表根域。 不过， 一般都不写最后那个句点， 因此根域的存在往往被忽略，但根域毕竟是真实存在的， 根域的 DNS 服务器中保管着com、 jp 等的 DNS 服务器的信息。由于上级 DNS 服务器保管着所有下级DNS 服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意一个域的 DNS 服务器。 

除此之外还需要完成另一项工作，那就是**将根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器**中。这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。因此，客户端只要能够找到任意一台DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器（ 图 1.15）。分配给根域 DNS 服务器的 IP 地址在全世界仅有 13 个 ，而且这些地址几乎不发生变化，因此将这些地址保存在所有的 DNS 服务器中也并不是一件难事。实际上，根域DNS 服务器的相关信息已经包含在DNS 服务器程序的配置文件中了，因此只要安装了 DNS 服务器程序，这些信息也就被自动配置好了。 

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220312091110204.png" alt="image-20220312091110204" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220312091316409.png" alt="image-20220312091316409" style="zoom:80%;" />

注：当我们客户端事先配置好的最近的DNS服务器上没有我们要访问的域名的IP地址时，DNS服务器会将查询消息**转发给**根域DNS服务器。如果也没有查询到，那根域会**返回**管理下级域的服务器地址。

现实中上级域和下级域有可能共享同一台 DNS 服务器，也就是**一台DNS服务器与多个域相对应**。在这种情况下，访问上级DNS服务器时就可以向下跳过一级DNS服务器，直接返回再下一级DNS服务器的相关信息。此外，有时候并不需要从最上级的根域开始查找，因为**DNS服务器有一个缓存功能**，可以记住之前查询过的域名。如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行。相比每次都从根域找起来说，缓存可以减少查询所需的时间。并且，当要查询的域名不存时，“不存在”这一响应结果也会被缓存。这样，当下次查询这个不存在的域名时，也可以快速响应。这个缓存机制中有一点需要注意，那就是信息被缓存后，原本的注册信息可能会发生改变，这时缓存中的信息就有可能是不正确的。因此，**DNS服务器中保存的信息都设置有一个有效期，当缓存中的信息超过有效期后，数据就会从缓存中删除。而且，在对查询进行响应时，DNS服务器也会告知客户端这一响应的结果是来自缓存中还是来自负责管理该域名的DNS服务器。** 

### 1.4 数据收发

浏览器不具有收发信息功能，而是将请求消息委托给协议栈执行收发操作，而真正收发数据的设备是网卡。通过DNS域名解析，我们DNS解析器已经将我们要访问的浏览器的IP地址存到了浏览器的内存里。协议栈执行收发操作之前，要和客户端建立数据流动的通道（便于形象理解），即建立套接字和服务器程序的套接字进行匹配。协议栈数据收发操作也是依靠操作系统中的Socket库。数据传输完后还要断开套接字的连接。

综上所述， 收发数据的操作分为若干个阶段， 可以大致总结为以下 4 个。

- 创建套接字（创建套接字阶段）
- 将管道连接到服务器端的套接字上（连接阶段）
- 收发数据（通信阶段）
- 断开管道并删除套接字（断开阶段）  

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220312093056507.png" alt="image-20220312093056507" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220312093519524.png" alt="image-20220312093519524" style="zoom:80%;" />

注：

- 创建套接字采用函数`socket()`，函数返回一个描述符，协议栈将描述符返回给程序。描述符是识别客户端内部不同的套接字的标识。
- 连接操作需要指定描述符、服务器端口号和服务器IP地址和自己端口号。描述符与IP地址都已经取得了。描述符是用来区别客户端内部不同套接字的，不用于告知网络连接的另一方。在客户端和浏览器都不知道对方套接字的描述符时，用端口号来确定对方的套接字。服务器上所使用的端口号是根据应用的种类事先规定好的， 仅此而已。比如 Web 是 80 号端口，电子邮件是 25 号端口 D。只要指定了事先规定好的端口号， 就可以连接到相应的服务器程序的套接字。其次，客户端在创建套接字时， 协议栈会为这个套接字随便分配一个端口号 。当协议栈执行连接操作时，会将这个随便分配的端口号通知给服务器。   

- 发送数据操作调用函数`write()`，接受数据操作调用函数`read()`。调用read 时需要指定用于存放接收到的响应消息的内存地址， 这一内存地址称为接收缓冲区。由于接收缓冲区是一块位于应用程序内部的内存空间，因此当消息被存放到接收缓冲区中时，就相当于已经转交给了应用程序。  
- 当浏览器收到数据之后，收发数据的过程就结束了。接下来，我们需要调用 Socket 库的 close 程序组件进入断开阶段。根据应用种类不同，客户端和服务器哪一方先执行 close 都有可能。

## 第二章 协议栈与网卡

### 2.0 总框架

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220312113952861.png" alt="image-20220312113952861" style="zoom:80%;" />

注：

- 操作系统内部了，其中包括协议栈。协议栈的上半部分有两块，分别是负责用TCP协议收发数据的部分和负责用UDP协议收发数据的部分，它们会接受应用程序的委托执行收发数据的操作。像浏览器、邮件等一般的应用程序都是使用TCP收发数据的，而像DNS查询等收发较短的控制数据的时候则使用UDP。下面一半是用IP协议控制网络包收发操作的部分。在互联网上传送数据时，数据会被切分成一个一个的网络包，而将网络包发送给通信对象的操作就是由IP来负责的。此外，IP中还包括ICMP协议和ARP协议。ICMP用于告知网络包传送过程中产生的错误以及各种控制消息，ARP用于根据IP地址查询相应的以太网MAC地址。
- IP下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作。 



消息收发操作应用程序、协议栈、服务器的关系如图2.3所示。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220312120320186.png" alt="image-20220312120320186" style="zoom: 80%;" />

整体流程

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313115500262.png" alt="image-20220313115500262" style="zoom:80%;" />

### 2.1 建立套接字

在**协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息**，例如通信对象的 IP 地址、端口号、通信操作的进行状态等。本来套接字就只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说**存放控制信息的内存空间就是套接字的实体**。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220312114841198.png" alt="image-20220312114841198" style="zoom:80%;" />

在 Windows 中可以用 netstat 命令显示套接字内容（图 2.2）。图中每一行相当于一个套接字，当创建套接字时，就会在这里增加一行新的控制信息，赋予“即将开始通信” 的状态，并进行通信的准备工作，如分配用于临时存放收发数据的缓冲区空间。  

第8行

- 它表示 PID 为 4 的程序正在使用 IP 地址为 10.10.1.16 的网卡与 IP 地址为10.10.1.18 的对象进行通信。此外我们还可以看出，本机使用 1031 端口，对方使用 139 端口，而 139 端口是 Windows 文件服务器使用的端口，因此我们就能够看出这个套接字是连接到一台文件服务器的。
  - PID： Process ID（进程标识符）的缩写，是操作系统为了标识程序而分配编号，使用任务管理器可以查询所对应的程序名称。  

第1行

- 这一行表示 PID 为 984 的程序正在 135 端口等待另一方的连接，其中本地 IP 地址和远程 IP 地址都是 0.0.0.0，这表示通信还没开始，IP 地址不确定 。  



创建套接字时，`socket()`函数执行以下操作。

- 分配内存空间

- 写入控制信息
- 返回描述符

套接字建立完成后，协议栈将描述符返回给应用程序。收到描述符之后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息，这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。通信对方的相关信息要通过连接操作自动完善。



### 2.2 连接

**连接实际上是通信双方交换控制信息。连接操作中所交换的控制信息是根据通信规则来确定的，只要根据规则执行连接操作，双方就可以得到必要的信息从而完成数据收发的准备。**

**连接操作执行操作如下：**

- 客户端在TCP模块处创建表示连接控制信息的头部。
  - 注：套接字的内的控制信息是用来控制协议栈操作的信息。应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发数据操作的执行状态等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作。操作系统的不同导致协议栈所需要的控制信息不同。我们无法列举这部分详细的控制信息。
  - TCP头部中的控制信息是客户端和服务器相互联络时交换的控制信息。这些信息不仅连接时需要，包括数据收发和断开连接操作在内，整个通信过程中都需要，这些内容在 TCP 协议的规格中进行了定义。
- 将客户端TCP头部发给服务器，服务器将客户端信息写入套接字。服务器建立TCP头部并发送给客户端，客户端TCP模块将服务器的信息写入套接字。客户端再发个ACK确认信息给服务器，连接建立完成。
- 在内存中分配内存空间用于建立数据收发缓冲区。



TCP头部格式控制信息如下：



<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220312180415394.png" alt="image-20220312180415394" style="zoom:80%;" />

连接操作如图1.17所示。

1. 客户端TCP建立头部。头部中写入发送方、接收方（服务器）的端口号。同时写入序号（表示数据起始字节）、窗口大小（数据收发操作时为了提高信道的利用率采用滑动窗口发送模式，提前告知窗口大小能防止数据接受量溢出）、控制位SYN设置为1（表示接下来对发送数据的起始字节要进行同步）。

2. TCP模块将TCP头部交给IP模块。IP模块委托网卡发送给服务器。服务器网卡接受->服务器IP模块->服务器TCP模块。**服务器TCP模块将发送端端口等信息写入对应的套接字里。**这样服务器就知道和谁进行通信了。

3. 服务器TCP模块建立TCP头部。控制位ACK设置为1（表示成功接受到客户端的信息），其余信息类型和第一步相同。（这一步网络包还没有数据，ACK号为1？）

4. 服务器TCP模块->服务器IP模块->服务器网卡->客户端网卡、IP模块、TCP模块。**客户端把接受到的信息写入套接字。**

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220312093056507.png" alt="image-20220312093056507" style="zoom:80%;" />

5. 客户端将TCP头部中的ACK控制位设置为1（应该是这样吧？书上讲得不是特别清除。由于此时网络包中没有数据，ACK号为1？）

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313094159181.png" alt="image-20220313094159181" style="zoom:80%;" />

### 2.3 数据收发操作

#### 网络包

存放数据的网络包和只有控制信息的网路包示意图如下图所示。如果应用程序数据是HTTP请求，那么数据包括请求行、消息头、消息行和消息体。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313095625031.png" alt="image-20220313095625031" style="zoom:80%;" />

#### 网络包数据拆分

发送数据时协议栈并不关心应用程序传来的数据是什么内容，因为内容无非是二进制数据。其次，协议栈并不是一收到数据就马上发送出去， 而是会将数据存放在内部的发送缓冲区中， 并等待应用程序的下一段数据。 如果一收到数据就马上发送出去，就可能会发送大量的小包，导致网络效率下降，因此需要在数据积累到一定量时再发送出去。至于积累多少数据由以下要素判断：   

- 每个网络包能容纳的数据长度  

  - MTU 表示一个网络包的最大长度，在以太网中一般是 1500 字节（ 图 2.5）。MTU 是包含头部的总长度，因此需要从MTU 减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作MSS。当从应用程序收到的数据长度超过或者接近 MSS 时再发送出去， 就可以避免发送大量小包的问题了。  

    <img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313095734529.png" alt="image-20220313095734529" style="zoom:80%;" />

  - 当HTTP请求消息很长时，要对数据进行拆分。

    <img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313095805950.png" alt="image-20220313095805950" style="zoom:80%;" />

- 时间
  - 当应用程序发送数据的频率不高的时候，如果每次都等到长度接近 MSS 时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，即便缓冲区中的数据长度没有达到 MSS，也应该果断发送出去。为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去。
- 应用程序
  - 如果仅靠协议栈来判断发送的时机可能会带来一些问题，因为长度和时间判断要是是矛盾的。如果长度优先，那么网络的效率提高，但可能会因为等待填满缓冲区而产生延迟；相反地，如果时间优先，那么延迟时间会变少，但又会降低网络的效率。
  - 应用程序在发送数据时可以指定一些选项，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据。像浏览器这种会话型的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因此一般会使用直接发送的选项。



#### 序号和ACK号

首先，TCP模块在拆分数据时，会先算好每一块数据相当于从头开始的第几个字节，接下来在发送这一块数据时，将算好的字节数写在TCP头部中，“序号”字段就是派在这个用场上的。然后，发送数据的长度也需要告知接收方，不过这个并不是放在TCP头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度，所以接收方可以用这种方法来进行计算。有了上面两个数值，我们就可以知道发送的数据是从第几个字节开始，长度是多少了。

在实际的通信中，序号并不是从1开始的，而是需要用随机数计算出一个初始值，这是因为如果序号都从1开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。但是如果初始值是随机的，那么对方就搞不清楚序号到底是从多少开始计算的，因此需要在开始收发数据之前将初始值告知通信对象。在套接字连接过程中，有一个将SYN控制位设为1并发送给服务器的操作，就是在这一步将序号的初始值告知对方的。实际上，在将SYN设为1的同时，还需要同时设置序号字段的值，而这里的值就代表序号的初始值。 

接收方接收到数据后，查看序号，判断数据传输是否遗漏（应该是把序号和ACK号进行比较，我猜，ACK号应该是表示下一个数据包首个数据在所有数据中的偏移量）。如果没有遗漏，再把序号值+数据长度+1写入ACK号。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313101342271.png" alt="image-20220313101342271" style="zoom:80%;" />

考虑数据双向传输情况（客户端会给服务器发送请求数据，服务器会给客户端发送响应数据，双方都要确保对方接收到了自己的完整数据）

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313105320208.png" alt="image-20220313105320208" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313105242686.png" alt="image-20220313105242686" style="zoom:80%;" />

TCP采用“序号+ACK号”的方式确认对方是否收到了数据，在得到对方确认之前，发送过的包都会保存在发送缓冲区中。如果对方没有返回某些包对应的ACK号，那么就重新发送这些包。这一机制非常强大。通过这一机制，我们可以确认接收方有没有收到某个包，如果没有收到则重新发送，这样一来，无论网络中发生任何错误，我们都可以发现并采取补救措施（重传网络包）。

反过来说，有了这一机制，我们就不需要在其他地方对错误进行补救了。因此，**网卡、集线器、路由器都没有错误补偿机制，一旦检测到错误就直接丢弃相应的包。**应用程序也是一样，因为采用TCP传输，即便发生一些错误对方最终也能够收到正确的数据，所以应用程序只管自顾自地发送这些数据就好了。不过，如果发生网络中断、服务器宕机等问题，那么无论TCP怎样重传都不管用。这种情况下，无论如何尝试都是徒劳，因此TCP会在尝试几次重传无效之后强制结束通信，并向应用程序报错。

##### 动态调整ACK号等待时间

当网络传输繁忙时就会发生拥塞，ACK 号的返回会变慢，如果发送发误以为接收方没有接收到数据，启用错误补偿机制重新发送网络包，会使网络变得更加拥堵，当然对接收方没有影响，因为接收方能根据序号识别出重复的网络包，会对其进行丢弃。除了网络状态、服务器距离发送方的远近也会影响ACK号的返回时间。因此，TCP采用了动态调整等待时间的方法，这个等待时间是根据ACK号返回所需的时间来判断的。具体来说，TCP会在发送数据的过程中持续测量ACK号的返回时间，如果ACK号返回变慢，则相应延长等待时间；相对地，如果ACK号马上就能返回，则相应缩短等待时间B。由于计算机的时间测量精度较低，ACK返回时间过短时无法被正确测量，因此等待时间有一个最小值，这个值在每个操作系统上不一样，基本上是在0.5秒到1秒之间。

##### 使用窗口有效管理ACK号

滑动窗口方式

数据传输采用一来一回方式（每发送一个数据包等待对方的ACK号后再发第二个包）浪费时间。于是采用滑动窗口方式**（在等待ACK号的时间里也在发送数据，在得到对方的ACK号确认之前，发送的数据先存在发送方的发送缓冲区内，如果对方没有返回某些包对应的 ACK 号， 那么就重新发送这些包）**。为了避免接收方的接受缓冲区溢出，连接时通信双方要告诉对方自己的窗口大小。同时还得更新窗口大小。更新窗口大小的时机为接收方从接受缓存区内拿出数据传递给应用程序后。更新ACK号的时机为接收方确认数据包没有遗漏。为了避免传输两个单独的包，可以把更新窗口大小的控制信号和更新ACK号的控制信号放在一个包里发送。同时，多个ACK号和多个窗口大小可以只去最后一个发送，这样也能减少包的数量。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313111611038.png" alt="image-20220313111611038" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313111622894.png" alt="image-20220313111622894" style="zoom:80%;" />

#### 接受HTTP相应消息

浏览器调用`read()`函数，使协议栈从接受缓冲区内取出数据传递给应用程序（取出分段数据后重新拼接）。如果刚执行发送HTTP请求操作接收缓冲区为空，读取操作暂时被挂起。



### 2.4 断开连接

发送完数据后，服务器和应用程序都有可能先断开。即先执行`close()`函数。

无论哪种情况，完成数据发送的一方会发起断开过程，这里我们以服务器一方发起断开过程为例来进行讲解。首先，服务器一方的应用程序会调用Socket库的close程序。然后，服务器的协议栈会生成包含断开信息的TCP头部，具体来说就是将控制位中的FIN比特设为1。接下来，协议栈会委托IP模块向客户端发送数据（图2.12①）。同时，服务器的套接字中也会记录下断开操作的相关信息。

接下来轮到客户端了。当收到服务器发来的FIN为1的TCP头部时，客户端的协议栈会将自己的套接字标记为进入断开操作状态。然后，为了告知服务器已收到FIN为1的包，客户端会向服务器返回一个ACK号图2.12②）。这些操作完成后，协议栈就可以等待应用程序来取数据了。

过了一会儿，应用程序就会调用read来读取数据A。这时，协议栈不会向应用程序传递数据，而是会告知应用程序（浏览器）来自服务器的数据已经全部收到了。因此，客户端应用程序会调用close来结束数据收发操作，这时客户端的协议栈也会和服务器一样，生成一个FIN比特为1的TCP包，然后委托IP模块发送给服务器（图2.12③）。一段时间之后，服务器就会返回ACK号（图2.12④）。到这里，客户端和服务器的通信就全部结束了。 

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313114611820.png" alt="image-20220313114611820" style="zoom:80%;" />

##### 删除套接字

和服务器的通信结束之后，用来通信的套接字也就不会再使用了，这时我们就可以删除这个套接字了。不过，套接字并不会立即被删除，而是会等待一段时间之后再被删除。

### 2.5 IP模块

#### IP模块作用

TCP模块将数据加上TCP头部后，打包送给IP模块。IP模块给数据包加上IP头部与MAC头部。加上两个头部的原因是，数据包是通过路由器、集线器这样的网络转发设备传输的。路由器是根据IP协议设计的，集线器是根据MAC协议设置的。它们的作用分别是：

- 路由器：根据目标地址判断下一个路由器的位置
- 集线器：在子网中将网络包传输到下一个路由

IP头部中包含IP协议规定的、根据IP地址将包发往目的地所需的控制信息；MAC头部包含通过以太网的局域网将包传输至最近的路由器所需的控制信息

发送方将包的目的地，也就是要访问的服务器的IP地址写入IP头部中。这样一来，IP协议就可以根据这一地址在路由表（routingtable）中查找包的传输方向，从而找到下一个路由器的位置，IP协议会查找下一个路由器的以太网地址（MAC地址），并将这个地址写入MAC头部中

之所以要把IP头部和MAC头部分开，原因是：以太网的部分也可以替换成其他的东西，例如无线局域网、ADSL、FTTH等，它们都可以替代以太网的角色帮助IP协议来传输网络包。因此，将IP和负责传输的网络分开，可以更好地根据需要使用各种通信技术。像互联网这样庞大复杂的网络，在架构上需要保证灵活性。

IP网络包经过集线器、路由器IP头部与MAC头部如图2-16所示

其中：

- IP头部是不变的。
- 由IP头部中的服务器的IP地址找到下一个路由器，并将其MAC地址写入MAC头部。收到包的时候MAC头部会被舍弃，而当再次发送的时候又会加上包含新MAC地址的新MAC头部。



<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313144916136.png" alt="image-20220313144916136" style="zoom:80%;" />



#### IP头部控制信息

IP头部含有的控制信息如表2.2所示。（关注协议号、发送方IP地址和接收方IP地址）。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313145740465.png" alt="image-20220313145740465" style="zoom:80%;" />



#### 查找 route table 确定发送方的IP地址

当一台计算机上有多个网络设备时，要根据路由表选择一个网络设备作为发送方的IP地址。我们可以通过 `route print`
命令来显示路由表。Interface就是发送方的IP地址，Gateway（网关）就是转发路由器的IP地址。我们根据前两列网络包的最终目的地来选择用计算机的哪一个网络IP地址进行发送。 

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313150617636.png" alt="image-20220313150617636" style="zoom:80%;" />

#### MAC头部控制信息

在生成MAC（MAC：Media Access Control）头部时，只要设置表2.3中的3个字段就可以了。

- 接受方MAC地址是在网卡生产时写入ROM里的，只要将这个值读取出来写入MAC头部就可以了。

  - 实际上，只有在操作系统启动过程中对网卡进行初始化的时候才会读取MAC地址，读取出来之后会存放在内存中，每次执行收发操作时实际上使用的是内存中的值。此外，读取MAC地址的操作是由网卡驱动程序来完成的，因此网卡驱动程序也可以不从网卡ROM中读取地址，而是将配置文件中设定的MAC地址拿出来放到内存中并用于设定MAC头部，或者也可以通过命令输入MAC地址。

- 发送方MAC地址要通过ARP（ARP：Address Resolution Protocol）解析。

  <img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313153808189.png" alt="image-20220313153808189" style="zoom:80%;" />

- MAC地址的两种写法

  <img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313154604311.png" alt="image-20220313154604311" style="zoom:80%;" />

#### ARP协议

在以太网中，有一种叫作广播的方法，可以把包发给连接在同一以太网中的所有设备。在广播之前，先查询ARP缓存，果其中已经保存
了对方的MAC地址，就不需要发送ARP查询，直接使用ARP缓存中的地址，而当ARP缓存中不存在对方MAC地址时，则发送ARP查询。不是这个IP地址的设备会忽略广播，什么都不回答。IP地址匹配的路由器会把MAC地址发给发送方。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313154217144.png" alt="image-20220313154217144" style="zoom:80%;" />

#### ARP缓存删除

当IP地址发生变化时，ARP缓存的内容就会和现实发生差异。为了防止这种问题的发生，ARP缓存中的值在经过一段时间后会被删除，一般这个时间在几分钟左右。这个删除的操作非常简单粗暴，不管ARP缓存中的内容是否有效，只要经过几分钟就全部删掉，这样就不会出问题了。当地址从ARP缓存中删除后，只要重新执行一次ARP查询就可以再次获得地址了。



#### 以太网

以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术，它的原型如图2.22（a）所示。从图上不难看出，这种网络的本质其实就是一根网线。图上还有一种叫作收发器的小设备，它的功能只是将不同网线之间的信号连接起来而已。因此，当一台计算机发送信号时，信号就会通过网线流过整个网络，最终到达所有的设备。不过，我们无法判断一个信号到底是发给谁的，因此需要在信号的开头加上接收者的信息，也就是地址。这样一来就能够判断信号的接收者了，与接收者地址匹配的设备就接收这个包，其他的设备则丢弃这个包，这样我们的包就送到指定的目的地了。

这个原型后来变成了图2.22（b）中的结构。这个结构是将主干网线替换成了一个中继式集线器，将收发器网线替换成了双绞线。不过，虽然网络的结构有所变化，但信号会发送给所有设备这一基本性质并没有改变。

后来，图2.22（c）这样的使用交换式集线器D的结构普及开来，现在我们说的以太网指的都是这样的结构。这个结构看上去和（b）很像，但其实里面有一个重要的变化，即信号会发送给所有设备这一性质变了，现在信号只会流到根据MAC地址指定的设备，而不会到达其他设备了。当然，根据MAC地址来传输包这一点并没有变，因此MAC头部的设计也得以保留。

尽管以太网经历了数次变迁，但其**基本的3个性质**至今仍未改变，

- **将包发送到MAC头部的接收方MAC地址代表的目的**
- **用发送方MAC地址识别发送方**
- **用以太类型识别包的内容**

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313155423373.png" alt="image-20220313155423373" style="zoom:80%;" />

#### 网卡

- 打开计算机启动操作系统的时候，网卡驱动程序会对硬件进行初始化操作，然后硬件才进入可以使用的状态。

- 每一个网卡都有一个独一无二的MAC地址。

  <img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313161724300.png" alt="image-20220313161724300" style="zoom:80%;" />

  工作过程：

  1. 网卡驱动从IP模块获取包之后，会将其复制到网卡内的缓冲区中，然后向MAC模块发送发送包的命令。

  2. MAC模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列（图2.24）。

     <img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313161531681.png" alt="image-20220313161531681" style="zoom:80%;" />

     - 报头是一串像10101010…这样1和0交替出现的比特序列，长度为56比特，它的作用是确定包的读取时机。

       <img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313162019751.png" alt="image-20220313162019751" style="zoom:80%;" />

     - 末尾的FCS（帧校验序列）用来检查包传输过程中因噪声导致的波形紊乱、数据错误，它是一串32比特的序列，是通过一个公式对包中从头到尾的所有内容进行计算而得出来的。当原始数据中某一个比特发生变化时，计算出来的结果就会发生变化。在包传输过程中，如果受到噪声的干扰而导致其中的数据发生了变化，那么接收方计算出的FCS和发送方计算出的FCS就会不同，这样我们就可以判断出数据有没有错误。 

#### 向集线器发送网络包

加上报头、起始帧分界符和FCS之后，我们就可以将包通过网线发送出去了（图2.24）。发送信号的操作分为两种，一种是使用集线器的半双工模式，另一种是使用交换机的全双工模式。

在半双工模式中，为了避免信号碰撞，PHY（MAU）首先要判断网线中是否存在其他设备发送的信号。如果有，则需要等待该信号传输完毕，因为如果在有信号时再发送一组信号，两组信号就会发生碰撞。两组信号相互叠加，无法彼此区分出来这种情况下，继续发送信号是没有意义的，因此发送操作会终止。为了通知其他设备当前线路已发生碰撞，还会发送一段时间的阻塞信号，然后所有的发送操作会全部停止。

首先，**MAC模块从报头开始将数字信息按每个比特转换成电信号（任意格式的通用信号），然后由PHY，或者叫MAU的信号收发模块发送出去。**（根据以太网信号方式的不同，有些地方叫MAU（Medium Attachment Unit，介质连接单元），有些地方叫PHY（Physical Layer Device，物理层装置）。在速率为100Mbit/s以上的以太网中都叫PHY。）在这里，**将数字信息转换为电信号的速率就是网络的传输速率，**例如每秒将10Mbit的数字信息转换为电信号发送出去，则速率就是10Mbit/s。接下来，PHY（MAU）模块会将信号转换为可在网线上传输的格式，并通过网线发送出去。**以太网规格中对不同的网线类型和速率以及其对应的信号格式进行了规定，但MAC模块并不关心这些区别，而是将可转换为任意格式的通用信号发送给PHY（MAU）模块，然后PHY（MAU）模块再将其转换为可在网线上传输的格式。**

**PHY（MAU）的职责并不是仅仅是将MAC模块传递过来的信号通过网线发送出去，它还需要监控接收线路中有没有信号进来。**

#### 接受返回包

- 首先，**PHY（MAU）模块会将信号转换成通用格式并发送给MAC模块，MAC模块再从头开始将信号转换为数字信息。当到达信号的末尾时，需要检查FCS。**
  - 具体来说，就是将从包开头到结尾的所有比特套用到公式中计算出FCS，然后和包末尾的FCS进行对比，正常情况下两者应该是一致的，如果中途受到噪声干扰而导致波形发生紊乱，则两者的值会产生差异，这时这个包就会被当作错误包而被丢弃。
- **如果FCS校验没有问题，接下来就要看一下MAC头部中接收方MAC地址与网卡在初始化时分配给自己的MAC地址是否一致，以判断这个包是不是发给自己的。**
- **如果包是发给自己的，将包存放到缓冲区中。**到这里，MAC模块的工作就完成了，接下来网卡会通知计算机收到了一个包。
- 网卡驱动被中断处理程序调用后，会从网卡的缓冲区中取出收到的包，并通过MAC头部中的以太类型字段判断协议的类型。网卡不会关心包里的内容，只要按照以太类型将包交给对应的协议栈就可以了。

#### 将服务器的响应包从IP传递给TCP

- 服务器返回的包的以太类型应该是0800，因此网卡驱动会将其交给TCP/IP协议栈来进行处理。

- IP模块
  - 检查IP头部，确认格式是否正确。
  - 是查看接收方IP地址是否是客户端网卡的IP地址
  - 分片重组
  - 将网络包转交给TCP模块

- 如果接收方的IP地址不是客户端网卡的IP地址，IP 模块会通过 ICMP 消息将错误告知发送方 。

  - ICMP：Internet Control Message Protocol，Internet 控制报文协议。当包传输过程中发生错误时，用来发送控制消息。

  <img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313215704049.png" alt="image-20220313215704049" style="zoom:80%;" />

- 到这里，IP模块的工作就结束了，接下来包会被交给TCP模块。TCP模块会根据IP头部中的接收方和发送方IP地址，以及TCP头部中的接收方和发送方端口号来查找对应的套接字。找到对应的套接字之后，就可以根据套接字中记录的通信状态，执行相应的操作了。例如，如果包的内容是应用程序数据，则返回确认接收的包，并将数据放入缓冲区，等待应用程序来读取；如果是建立或断开连接的控制包，则返回相应的响应控制包，并告知应用程序建立和断开连接的操作状态。

### 2.6 UDP 协议

**TCP之所以复杂，是为了实现高效的传输，避免重发已经送达的包，而是只重发那些出错的或者未送达的包。**

UDP没有TCP的接收确认、窗口等机制，因此在收发数据之前也不需要交换控制信息，也就是说**不需要建立和断开连接的步骤，只要在从应用程序获取的数据前面加上UDP头部，然后交给IP进行发送就可以了**（表2.5）。**接收也很简单，只要根据IP头部中的接收方和发送方IP地址，以及UDP头部中的接收方和发送方端口号，找到相应的套接字并将数据交给相应的应用程序就可以了。**除此之外，UDP协议没有其他功能了，遇到错误或者丢包也一概不管。因为UDP只负责单纯地发送包而已，并不像TCP一样会对包的送达状态进行监控，所以协议栈也不知道有没有发生错误。但这样并不会引发什么问题，**因此出错时就收不到来自对方的回复，应用程序会注意到这个问题，并重新发送一遍数据。**这样的操作本身并不复杂，也并不会增加应用程序的负担。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313172312912.png" alt="image-20220313172312912" style="zoom:80%;" />

适用场景：

- 数据短，可以放在一个包里面
- 必须在规定时间内送达的数据，比如音频、视频数据。



## 第三章

### 3.0 总结构

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314081222145.png" alt="image-20220314081222145" style="zoom:80%;" />

### 3.1 集线器

集线器的内部结构如图3.2左侧部分所示。首先，在每个接口的后面装有和网卡中的PHY（MAU）功能相同的模块，但如果它们像网卡端一样采用直连式接线，是无法正常接收信号的。要**正常接收信号，必须将“发送线路”和“接收线路”连接起来才行。**在图3.2中，集线器中的PHY（MAU）模块与接口之间采用交叉接线的原因正是在于此。

MDI是Media Dependent Interface（媒体相关接口）的缩写，MDI-X是MDI-Crossover的缩写。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314081849354.png" alt="image-20220314081849354" style="zoom: 67%;" />

MDI就是对RJ-45接口和信号收发模块进行直连接线，而MDI-X则是交叉接线。由于集线器的接口一般都是MDI-X模式，要将两台集线器相连时，就需要将其中一台改成MDI模式（图3.5（a））。如果集线器上没有MDI切换开关，而且所有的接口又都是MDI-X时，可以用交叉网线连接两台集线器。所谓交叉网线，就是一种将发送和接收信号线反过来接的网线（图3.6）。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314082939037.png" alt="image-20220314082939037" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314083020280.png" alt="image-20220314083020280" style="zoom:80%;" />

以太网中的信号波形是方形的，但损失能量会让信号的拐角变圆，这是因为电信号的频率越高，能量的损失率越大。信号的拐角意味着电压发生剧烈的变化，而剧烈的变化意味着这个部分的信号频率很高。高频信号更容易损失能量，因此本来剧烈变化的部分就会变成缓慢的变化，拐角也就变圆了。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314081705755.png" alt="image-20220314081705755" style="zoom:80%;" />

双绞线能对噪声产生抑制

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314081728855.png" alt="image-20220314081728855" style="zoom:80%;" />

### 3.2 交换机

#### 交换机的结构和收发数据过程

交换机的结构如图3.7所示。

交换机的结构类似网卡，当信号到达网线接口，由PHY（MAU）模块进行接收PHY（MAU）模块会将网线中的信号转换为通用格式，然后传递给MAC模块。MAC模块将信号转换为数字信息，然后通过包末尾的FCS校验错误，如果没有问题则存放到缓冲区中。

但是**交换机没有MAC地址**，所以交换机进行完FCS检验没有发现错误后，不会检验MAC地址是不是自己的地址，而是直接接收所有的包并存放到缓冲区中。然后通过查MAC与端口对应的表，决定MAC地址应该发送给哪一个端口。

输入端口和输出端口的连接可以参考**交换电路**的设计思路。如图3.8所示。交换机有多个端口，可以同时进行多个包的转发操作。而集线器一次只能接受一个包广播一个包，如果收到多个包，信号会在集线器内发生碰撞。故交换机的效率高于集线器。

当网络包通过交换电路到达发送端口时，端口中的MAC模块和PHY（MAU）模块会执行发送操作，将信号发送到网线中，这部分和网卡发送信号的过程是一样的。根据以太网的规则，首先应该确认没有其他设备在发送信号，也就是确认信号收发模块中的接收线路没有信号进来。如果检测到其他设备在发送信号，则需要等待信号发送完毕；如果没有其他信号，或者其他信号已经发送完毕，这时就可以将包的数字信息转换为电信号发送出去。在发送信号的过程中，还需要对接收信号进行监控，这一点和网卡也是一样的。如果在发送过程中检测到其他设备发送信号，就意味着出现了信号碰撞，这时需要发送阻塞信号以停止网络中所有的发送操作，等待一段时间后再尝试重新发送，这一步和网卡也是一样的。（**这个操作过程的前提是终端通过集线器连接到交换机，也就是半双工模式的工作方式。这是以太网的原型，但现在基本上都不使用集线器了，而是直接用交换机将终端和路由器相连接，在这种情况下，交换机的端口会自动切换为全双工模式。**） 

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314082020867.png" alt="image-20220314082020867" style="zoom: 80%;" />

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314084132594.png" alt="image-20220314084132594" style="zoom:80%;" />





#### MAC地址表的维护

维护就是对MAC地址-端口对应表进行增加与删除的操作。

- 第一种是收到包时，将发送方MAC地址以及其输入端口的号码写入MAC地址表中。由于收到的那个端口就连接着发送这个包的设备，所以只要将这个包的发送方MAC地址写入地址表，以后收到发往这个地址的包时，交换机就可以将它转发到正确的端口了。交换机每次收到包时都会执行这个操作，因此只要某个设备发送过网络包，它的MAC地址就会被记录到地址表中。
  - 当交换机第一次接受到包时，MAC地址表接受到了发送方的MAC地址和发送方的端口。但是不知道这个包接收方的MAC地址对应的端口号。所以不能成功发送数据。这种情况为地址表中找不到指定的MAC地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。这种情况下，交换机无法判断应该把包转发哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后只有相应的接收者才接收包，而其他设备则会忽略这个包。
- 另一种是删除地址表中某条记录的操作，这是为了防止设备移动时产生问题。设备发生移动后，端口就不和设备对应了，通信会发生错误。因此地址表中的记录不能永久有效，而是要在一段时间不使用后就自动删除。交换机会自行更新或删除地址表中的记录，不需要手动维护。当地址表的内容出现异常时，只要重启一下交换机就可以重置地址表，也不需要手动进行维护。

#### 特殊情况

当交换机查询地址表之后发现记录中的目标端口和这个包的源端口是同一个端口，会直接丢弃这个包  。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314085113445.png" alt="image-20220314085113445" style="zoom:80%;" />

#### 全双工模式

当交换机不与集线器相连，信号就不会通过集线器发给它所连接的所有设备，信号就不会发生碰撞，就可以停用碰撞检测。在全双工模式下，无需等待其他信号结束就可以发送信号，因此它比半双工模式速度要快。由于双方可以同时发送数据，所以可同时传输的数据量也更大，性能也就更高。



### 3.3 路由器

#### 路由器的结构

路由器可以简单看成端口模块与包转发模块。通过更换支持不同通信技术的端口模块，可以支持不同通信协议的包的收发操作。以以太网端口为例，路由器的端口就有MAC地址。当端口的 MAC 地址和包的接收方MAC 地址一致时，端口才接受这个包，否则就丢弃包。而交换机不检查MAC地址，因为自己本身不具有MAC地址。  

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314164821764.png" alt="image-20220314164821764" style="zoom:80%;" />

#### 路由表

**路由器则是根据 IP 头部中的 IP 地址来判断包的转发目标；交换机根据 MAC 头部中的 MAC 地址来判断包的转发目标。**

根据路由表，路由器只会匹配IP地址中的网络号。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314170430466.png" alt="image-20220314170430466" style="zoom:80%;" />

- 路由器会忽略主机号，只匹配网络号。
- 如果子网掩码没有0，即目标地址没有主机号，此时这个目标地址表示一台计算机。例如上图中的第二行、第四行。
- 最后一列是跃点计数，它表示距离目标IP地址的距离是远还是近。这个数字越小，表示距离目的地越近；数字越大，表示距离目的地越远。

#### 路由聚合

地址本身的子网掩码和路由表中的子网掩码是不一致，这是路由聚合的结果。

如图3.14所示，我们现在有3个子网，分别为10.10.1.0/24、10.10.2.0/24、10.10.3.0/24，路由器B需要将包发往这3个子网。在这种情况下，路由器B的路由表中原本应该有对应这3个子网的3条记录，但在这个例子中，无论发往任何一个子网，都是通过路由器A来进行转发，因此我们可以在路由表中将这3个子网合并成10.10.0.0/16，这样也可以正确地进行转发，但我们减少了路由表中的记录数量，这就是路由聚合。经过路由聚合，多个子网会被合并成一个子网，子网掩码会发生变化，同时，目标地址列也会改成聚合后的地址。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314165713646.png" alt="image-20220314165713646" style="zoom:80%;" />

#### 包接受操作

与网卡接受包的操作相同（只有IP模块的包接受操作才会检验IP地址是不是自己的IP地址，交换机、路由器都只检验MAC头部）

- 端口电信号经过PHY(MAU)模块被转化为通过格式信号，经过MAC模块转化为数字信号。
- FSC检验。如果有误，丢弃包。
- MAC头部检验，如果不是发给自己的包，丢弃。
- 将网络包存入缓存区。

#### 查询路由表确定输出端口

- **当IP地址匹配路由表中的多条信息时，路由器首先寻找网络号比特数最长的一条记录C。**
  - 网络号比特数越长，说明主机号比特数越短，也就意味着该子网内可分配的主机数量越少，即子网中可能存在的主机数量越少，这一规则的目的是尽量缩小范围，所以根据这条记录判断的转发目标就会更加准确。
- **当路由表中会存在网络号长度相同的多条记录，这时根据跃点数来判断选择哪条记录。**
  - 跃点数越小，优先级越高（表示越近）。
- **找不到匹配路由选择默认路由。**（因为路由表中不可能存储所有的IP转发地址）
  - 子网掩码0.0.0.0表示默认路由。默认路由对应的网关地址为默认网关。
- 如果在路由表中无法找到匹配的记录，路由器会丢弃这个包，并通过ICMP消息告知发送方。  

#### 包的有效期

从路由表中查找到转发目标之后，网络包就会被转交给输出端口，并最终发送出去，但在此之前，更新IP头部中的TTL（TimetoLive，生存时间）字段。

TTL字段表示包的有效期，包每经过一个路由器的转发，这个值就会减1，当这个值变成0时，就表示超过了有效期，这个包就会被丢弃。

这个机制是为了防止包在一个地方陷入死循环。如果路由表中的转发目标都配置正确，应该不会出现这样的情况，但如果其中的信息有问题，或者由于设备故障等原因切换到备用路由时导致暂时性的路由混乱，就会出现这样的情况。

发送方在发送包时会将TTL设为64或128，现在的互联网即便访问一台位于地球另一侧的服务器，最多也只需要经过几十个路由器，因此只要包被正确转发，就可以在过期之前到达目的地。 

#### 分片

路由器的端口并不只有以太网一种， 也可以支持其他局域网或专线通信技术。不同通信技术规定了一次传输的最大包长度。一旦转发的包长度超过了输出端口能传输的最大长度， 就无法直接发送这个包了。注：输入端口的包一定不会超过最大长度（因为这个包已经开始传输了）。

不同的线路和局域网类型各自能传输的最大包长度也不同， 因此输出端口的最大包长度可能会小于输入端口 。 即便两个端口的最大包长度相同， 也可能会因为添加了一些头部数据而导致包的实际长度发生变化。

当遇到输出端口的最大包长度可能会小于输入端口，可以执行分片操作。

1. 计算MTU。包的最大长度减去头部长度就是MTU，如果端口为以太网端口，头部就指的是MAC头部。

   - 如果MTU长度超过小于要转发包的长度，考虑分片。否则，直接发送即可。

   <img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220313095734529.png" alt="image-20220313095734529" style="zoom:80%;" />

2. 查看IP 头部中的标志字段，确认是否可以分片。
   - 如果查询标志字段发现不能分片，那么就只能丢弃这个包，并通过ICMP消息通知发送方。
   - 一般来说都是可以分片的，但下面两种情况不能分片：1）发送方应用程序等设置了不允许分片；2）这个包已经是经过分片后的包。
3. 执行分片操作。如下图。
   - 在分片中，TCP头部及其后面的部分都是可分片的数据。
   - 数据被拆分后，每一份数据前面会加上IP头部，其大部分内容都和原本的IP头部一模一样，但其中有部分字段需要更新，这些字段用于记录分片相关的信息。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314174501838.png" alt="image-20220314174501838" style="zoom:80%;" />

#### 包的发送

这一步取决于输出端口的类型，以以太网端口为例。

- 生成MAC头部。
  1. 查路由表的网关。如果网关是一个 IP 地址， 则这个IP 地址就是我们要转发到的目标地址； 如果网关为空 C， 则 IP 头部中的接收方 IP 地址就是要转发到的目标地址。   
  2. 通过ARP（Adress Resolution Protocol）缓存找到出接受方的MAC地址，写入MAC头部。如果没有找到通过广播方式找到接受方MAC地址。
  3. 将输出端口的MAC地址写入MAC头部。
  4. 写入协议类型，以太网端口协议号是0x0080。
  5. 给MAC模块加入头尾帧，数字信号转化为通用信号格式。
  6. 发给PHY(MAU)转化为电信号，等待发送。如果是半双工模式，且发送信道空闲，开始发送。

#### 路由器和交换机的关系

IP 协议本身没有传输包的功能， 因此包的实际传输要委托以太网来进行。即将IP数据包加上头部（如果是靠以太网传输就加上MAC头部）。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314180530182.png" alt="image-20220314180530182" style="zoom:80%;" />  

​	

#### 路由器的附加功能

##### 地址转换

为了防止IP地址不够分，把不需要和互联网交互的内网分配私有地址，把需要和互联网交互的网络分配共有地址。私有地址和共有地址间的转换依靠**地址转换设备**。

地址转换设备中有**地址和端口对应表**。当客户端要对服务器发送数据时，服务器的共有地址我们是可以通过DNS进行域名解析得到的，端口号也能知道（？）。私有地址就是地址转换器的ip地址，发送方的端口号是地址转换器随机分配的空闲端口。这样我们就完善了地址和端口对应表。

之所以要存储私有地址的端口号是因为，通过改变端口号就能实现一个共有地址对应多个私有地址。端口号是一个16比特的数值， 理论上有65536个端口，但并不是所有端口都能用于地址转换。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314193909959.png" alt="image-20220314193909959" style="zoom:80%;" />

**从内网访问互联网之所以行得通是因为我们能不和互联网进行通信的前提下，完善端口和地址对应表。但互联网不能给内网发送网络包，因为互联网不知道内网的私有地址和端口号。除了正在访问的设备，能向和互联网通信中使用的那个端口发送网络包，无法向其他端口发送包。**也就是说，除非公司主动允许，否则是无法从互联网向公司内网发送网络包的。这种机制具有**防止非法入侵的效果**。 

如果我们希望互联网能给内网发包，只要手动添加记录完善**地址和端口对应表**就好。

<img src="https://raw.githubusercontent.com/Chenyuehan1/HowNetworksWork-NOTES/main/img/image-20220314195221218.png" alt="image-20220314195221218" style="zoom:80%;" />

**包过滤**

包过滤就是是在对包进行转发时，根据 MAC 头部、 IP 头部、 TCP 头部的内容，按照事先设置好的规则决定是转发这个包，还是丢弃这个包。我们通常说的防火墙设备或软件，大多数都是利用这一机制来防止非法入侵的。

